class Implicant:
    def __init__(self, implicant: str, covered_minterms=None):
        if not isinstance(implicant, str):
            raise TypeError("implicant must be a string")
        self.implicant_str = implicant
        self.implicant = self.convert_to_tuple(implicant)
        self.implicant_bin = self.convert_to_binary_tuple(self.implicant)
        self.hamming_weight = self.calculate_hamming_weight(self.implicant_bin)
        self.covered_minterms = self.initialize_covered_minterms(covered_minterms)
        self.is_prime = True

    def convert_to_tuple(self, implicant_str):
        result = []
        index = len(implicant_str) - 1
        while index >= 0:
            if implicant_str[index] == "'":
                result.insert(0, implicant_str[index - 1] + implicant_str[index])
                index -= 1
            else:
                result.insert(0, implicant_str[index])
            index -= 1
        return tuple(result)

    def convert_to_binary_tuple(self, implicant):
        return tuple([0 if element[-1] == "'" else 1 for element in implicant])

    def calculate_hamming_weight(self, implicant_bin):
        return sum(implicant_bin)

    def initialize_covered_minterms(self, covered_minterms):
        if not covered_minterms:
            return [sum(self.implicant_bin)]
        else:
            return covered_minterms

    def __repr__(self):
        return f"{self.implicant_str}({', '.join(map(str, self.covered_minterms))})"

    def __getitem__(self, index):
        return self.implicant[index]

    def simplify(self, another_implicant):
        if not isinstance(another_implicant, Implicant):
            raise TypeError("another_implicant must be of Implicant class")

        count_of_differences = 0
        result = ""
        index = 0

        if len(self.implicant) != len(another_implicant.implicant):
            return None

        while index < len(self.implicant):
            if self.implicant[index] == another_implicant.implicant[index]:
                result = f'{result}{self.implicant[index]}'
            else:
                count_of_differences += 1

            index += 1

        if count_of_differences != 1:
            return None

        return Implicant(result, covered_minterms=self.covered_minterms + another_implicant.covered_minterms)


if __name__ == "__main__":
    implicant1 = Implicant("a'bc")
    implicant2 = Implicant("abc")
    print(implicant1)
    result = implicant1.simplify(implicant2)
    print(result)
